Great tweak—keeping it simple with plain Python lists. I’ll keep explanations short for your slides and give you comment-free code blocks you can drop into a training notebook.

Means (arithmetic, geometric, harmonic)

When to use

Arithmetic: normal average for additive quantities (e.g., monthly income).

Geometric: compounding/multiplicative effects (returns, growth).

Harmonic: averaging rates/ratios; emphasizes smaller values.


import math

incomes = [42000, 51000, 49500, 55000, 60000, 46000, 52500, 57000, 58500, 310000]

arith_mean = sum(incomes) / len(incomes)
geom_mean = math.prod(incomes) ** (1/len(incomes))
harm_mean = len(incomes) / sum(1/x for x in incomes)

print(arith_mean, geom_mean, harm_mean)

Median (odd vs even)

Why: robust to outliers/skew.

import statistics as stats

income_odd = [42000, 51000, 49500, 55000, 60000, 46000, 52500, 57000, 58500]
income_even = [42000, 51000, 49500, 55000, 60000, 46000, 52500, 57000]

median_odd = stats.median(income_odd)
median_even = stats.median(income_even)

print(median_odd, median_even)

Mode on loan terms (months)

Definitions
Unimodal: one most frequent term.
Bimodal: two tied most frequent terms.
Multimodal: three or more tied most frequent terms.

import statistics as stats

loan_terms_uni = [12,12,12,6,24,12,18,12,24,36]
loan_terms_bi = [12,24,12,24,6,18,36,12,24,18,36,6]
loan_terms_multi = [6,12,18,6,12,18,6,12,18]

print(stats.multimode(loan_terms_uni))
print(stats.multimode(loan_terms_bi))
print(stats.multimode(loan_terms_multi))

Imputing missing loan terms when there are multiple modes

Choices

Random among tied modes.

Proportional to observed frequencies.

Conditional within a subgroup (best for ML when a predictor exists).


import random
import statistics as stats
from collections import Counter

random.seed(7)
loan_terms = [12,6,18,12,18,6,None,None,None]
observed = [x for x in loan_terms if x is not None]
modes = stats.multimode(observed)
filled_random = [x if x is not None else random.choice(modes) for x in loan_terms]
print(filled_random)

import random
from collections import Counter

random.seed(7)
loan_terms = [12,6,18,12,18,6,None,None,None]
obs_counts = Counter(x for x in loan_terms if x is not None)
cats = list(obs_counts.keys())
weights = [obs_counts[c]/sum(obs_counts.values()) for c in cats]
filled_prop = [x if x is not None else random.choices(cats, weights=weights, k=1)[0] for x in loan_terms]
print(filled_prop)

import random
import statistics as stats

random.seed(7)
segments = ["Retail","Retail","SME","SME","Retail","SME","Retail","SME","Retail"]
loan_terms = [12,6,18,12,18,6,None,None,None]

filled_conditional = loan_terms[:]
for seg in set(segments):
    idx = [i for i,(s,v) in enumerate(zip(segments,loan_terms)) if s==seg]
    obs = [loan_terms[i] for i in idx if loan_terms[i] is not None]
    if not obs:
        continue
    modes = stats.multimode(obs)
    choice = random.choice(modes)
    for i in idx:
        if filled_conditional[i] is None:
            filled_conditional[i] = choice

print(list(zip(segments, filled_conditional)))

Want quick mini-exercises to pair with this (e.g., “change one term to 60 and predict which summary shifts most”)?



Alright — let’s make this training-friendly with plain lists, banking-themed, and short examples you can reuse in slides.


---

Geometric Mean Example

Scenario:
An investment grows by 10% the first year, 20% the second year, and -15% the third year.
The geometric mean tells you the average yearly growth rate, accounting for compounding.

import math

growth_factors = [1.10, 1.20, 0.85]  
geom_mean = math.prod(growth_factors) ** (1/len(growth_factors)) - 1  
print(f"Average annual growth rate: {geom_mean*100:.2f}%")

Why geometric mean here?
Because returns multiply over time — you can’t just average percentages directly.


---

Harmonic Mean Example

Scenario:
A bank measures the average interest rate across three loans of equal principal:

Loan 1: 4%

Loan 2: 6%

Loan 3: 8%


interest_rates = [0.04, 0.06, 0.08]  
harm_mean = len(interest_rates) / sum(1/r for r in interest_rates)  
print(f"Average interest rate: {harm_mean*100:.2f}%")

Why harmonic mean here?
It’s best for rates (like speed, interest, P/E ratios) where you want each observation to have equal weight, not just the average of the rates.


---

If you want, I can also give you one visual slide-ready diagram showing when to use arithmetic, geometric, and harmonic mean so learners instantly remember. That would make it pop in your GenuDeck. Do you want me to prepare that?



